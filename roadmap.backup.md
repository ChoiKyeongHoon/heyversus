# heyversus 프로젝트 리뷰 및 개선 제안

## 프로젝트 개요 및 현재 상태 스냅샷

### 기술 요약과 핵심 기능
- **스택**: Next.js 15.5.2, React 19.1.0, TypeScript, Tailwind CSS v4, Supabase 백엔드.
- **목적**: 실시간 투표 생성·참여·조회가 가능한 웹 애플리케이션.
- **주요 기능**: 투표 생성/참여/조회, 실시간 결과, 공유 링크, 로그인/회원가입.

### 최근 해결된 주요 이슈
- **PollPageProps 타입 부재**: `src/app/poll/[id]/PollClient.tsx`에서 `{ params: { id: string } }`로 인라인 타입 지정.
- **create_new_poll 미정의**: Supabase에 `create_new_poll` SQL 함수 생성 및 배포.
- **increment_vote 함수 생성**: 옵션 투표 증가용 SQL 함수 정의.
- **question/title 불일치**: `src/lib/types.ts` 등에서 `question`을 `title`로 교정해 데이터 필드 정합성 확보.

### 현재 기능 상태
- ✅ 투표 생성: 정상 동작.
- ✅ 투표 조회: 정상 동작.
- ⚠️ 투표 진행: `increment_vote` RPC 파라미터 명이 일관되지 않아 일부 페이지에서 실패 가능성.

### 데이터 모델 참고
- `polls(id, title, is_public, created_at, user_id)`
- `poll_options(id, poll_id, text, votes, image_url, created_at)`

### 남은 과제 및 제안된 다음 단계
1. 모든 컴포넌트에서 `increment_vote` 호출 파라미터를 `option_id`로 통일.
2. 잔존 `poll.question` 참조를 `poll.title`로 교체.
3. 전 기능 플로우 회귀 테스트(생성 → 조회 → 투표) 수행.

위 요약은 `project-analysis-summary.md`의 내용을 통합한 것으로, 아래 상세 리뷰 섹션과 중복되지 않는 핵심 현황만 선별했습니다.

## 1. 아키텍처 및 데이터 관리

### 1.1. 데이터 페칭 로직 분리 및 재사용성 강화

- **문제점**: 현재 데이터 페칭 로직(Supabase 클라이언트 호출)이 서버 컴포넌트(`page.tsx`) 내에 직접 작성되어 있습니다. 이는 코드의 중복을 유발하고, 데이터 캐싱이나 재검증(`revalidate`) 같은 고급 데이터 관리 전략을 일관되게 적용하기 어렵게 만듭니다.
- **개선 제안**:
    1.  **Service Layer 도입**: `src/lib/services/polls.ts`와 같은 서비스 파일을 생성하여, 투표 데이터를 가져오는 함수(`getPolls`, `getPollById` 등)를 중앙에서 관리합니다.
    2.  **Next.js 캐싱 활용**: 서비스 함수 내에서 `next: { revalidate: 3600 }` 또는 `tags`를 이용한 캐싱 전략을 적용하여 성능을 최적화하고 API 호출을 줄입니다.
    3.  **컴포넌트 단순화**: 서버 컴포넌트에서는 `import { getPolls } from '@/lib/services/polls'`와 같이 해당 함수를 호출하여 데이터를 가져오기만 하도록 역할을 단순화합니다.
- **기대 효과**:
    - **유지보수성 향상**: 데이터 로직이 변경될 경우, 서비스 파일만 수정하면 되므로 유지보수가 용이해집니다.
    - **코드 재사용성**: 동일한 데이터를 필요로 하는 여러 컴포넌트에서 서비스 함수를 재사용할 수 있습니다.
    - **성능 최적화**: 일관된 캐싱 전략을 통해 애플리케이션의 전반적인 성능이 향상됩니다.

### 1.2. API Route Handlers를 이용한 백엔드 로직 분리

- **문제점**: 투표 생성(`create_new_poll`), 투표하기(`increment_vote`)와 같은 데이터 변경 작업이 클라이언트 컴포넌트에서 Supabase 함수를 직접 호출하는 방식으로 구현되어 있습니다. 이는 클라이언트에 비즈니스 로직이 노출될 수 있으며, 복잡한 유효성 검사나 서버 측 전용 로직(예: 포인트 지급, 알림 발송)을 추가하기 어렵습니다.
- **개선 제안**:
    1.  **API Route 생성**: `src/app/api/polls/route.ts` 및 `src/app/api/polls/[id]/vote/route.ts`와 같은 API Route Handler를 생성합니다.
    2.  **백엔드 로직 이전**: 데이터 생성, 수정, 삭제와 관련된 Supabase 호출 및 비즈니스 로직을 이 API Route들로 이전합니다.
    3.  **클라이언트 단순화**: 클라이언트 컴포넌트에서는 `fetch` API를 사용하여 해당 API Route를 호출하도록 변경합니다. 이를 통해 클라이언트는 서버의 구현细节을 알 필요가 없어집니다.
- **기대 효과**:
    - **보안 강화**: 민감한 비즈니스 로직이 서버 측에만 존재하여 보안이 강화됩니다.
    - **관심사 분리 (SoC)**: 프론트엔드(UI)와 백엔드(비즈니스 로직)의 역할이 명확하게 분리됩니다.
    - **확장성**: 향후 외부 서비스 연동, 로깅, 복잡한 트랜잭션 처리 등을 API Route 내에서 쉽게 확장할 수 있습니다.

## 2. UI/UX 및 상태 관리

### 2.1. Optimistic Updates를 통한 사용자 경험 향상

- **문제점**: 사용자가 투표 버튼을 클릭했을 때, 서버로부터 응답이 오기까지 약간의 지연 시간(latency)이 발생하며, 이 시간 동안 UI에는 즉각적인 변화가 없습니다. 이는 사용자에게 앱이 느리다는 인상을 줄 수 있습니다.
- **개선 제안**:
    1.  **React-Query 또는 SWR 도입**: 데이터 페칭 및 상태 관리를 위해 `React-Query`(`@tanstack/react-query`)나 `SWR`과 같은 라이브러리를 도입합니다.
    2.  **낙관적 업데이트 구현**: 사용자가 투표 버튼을 누르면, 서버 응답을 기다리지 않고 즉시 UI(투표 수, 투표 비율 등)를 업데이트합니다.
    3.  **에러 처리**: 만약 서버 요청이 실패하면, UI를 이전 상태로 되돌리고(rollback) 사용자에게 에러 메시지를 표시합니다.
- **기대 효과**:
    - **응답성 향상**: 사용자는 자신의 행동에 대한 즉각적인 시각적 피드백을 받아 앱이 매우 빠르다고 느끼게 됩니다.
    - **견고한 데이터 관리**: `React-Query`나 `SWR`은 캐싱, 재시도, 포커스 시 자동 갱신 등 복잡한 UI 데이터 상태 관리를 손쉽게 처리해줍니다.

### 2.2. 로딩·오류·빈 상태 처리 표준화

- **문제점**: 데이터 로딩, 에러 발생, 데이터가 없는 경우에 대한 UI 처리가 각 컴포넌트마다 다르게 구현될 수 있어 일관성이 떨어지고 코드 중복이 발생합니다.
- **개선 제안**: 공통 UI 상태를 처리하는 재사용 가능한 컴포넌트를 `src/components/common`과 같은 디렉터리에 만들어 표준화합니다.
    - **`Skeleton.tsx`**: 데이터 로딩 중에 표시할 스켈레톤 UI.
    - **`ErrorState.tsx`**: API 오류 발생 시 재시도 버튼 등을 포함한 오류 메시지를 표시.
    - **`EmptyState.tsx`**: 표시할 데이터가 없을 때(예: '아직 생성된 투표가 없습니다.') 안내 메시지를 표시.
- **기대 효과**:
    - **일관된 UX**: 애플리케이션 전체에서 로딩, 오류, 빈 상태에 대한 사용자 경험이 통일됩니다.
    - **개발 효율성 증대**: 반복적인 UI 상태 처리 로직을 작성할 필요 없이, 래퍼 컴포넌트를 재사용하여 개발 속도를 높일 수 있습니다.

### 2.3. 경량 전역 상태 관리 도입

- **문제점**: `useState`, `useEffect`를 사용한 개별 컴포넌트 상태 관리는 여러 컴포넌트에서 공유되는 상태(예: 사용자 인증 정보, 투표 작성 임시 데이터)를 다루기 비효율적이며, Prop Drilling을 유발할 수 있습니다.
- **개선 제안**: `Zustand`나 `Jotai` 같은 경량 전역 상태 관리 라이브러리를 도입합니다. `src/lib/stores/` 디렉터리 내에 `useSessionStore.ts` 와 같이 상태별 스토어를 생성하여, 여러 컴포넌트에서 공유하는 클라이언트 상태를 중앙에서 관리합니다.
- **기대 효과**: Prop Drilling을 방지하고, 여러 컴포언트에서 사용되는 상태를 일관되게 동기화할 수 있습니다. 상태가 변경될 때 해당 상태를 구독하는 컴포넌트만 리렌더링하여 성능을 최적화합니다.

### 2.4. Tailwind 기반 디자인 시스템 확장

- **문제점**: `button.tsx` 외에 카드, 뱃지, 폼 입력 등 공통 UI 컴포넌트가 부족하여 UI 개발 시 중복된 스타일링 코드가 발생하고, 애플리케이션 전반의 디자인 일관성을 유지하기 어렵습니다.
- **개선 제안**: `shadcn/ui`와 유사한 컴포넌트 기반 디자인 시스템을 확장합니다. `src/components/ui/`에 `Card.tsx`, `Badge.tsx`, `Input.tsx` 등 재사용 가능한 컴포넌트를 추가하고, CSS 변수를 활용한 테마(라이트/다크 모드) 관리 및 레이아웃 표준화를 진행합니다.
- **기대 효과**: 앱 전체의 디자인 일관성을 확보하고, 미리 정의된 컴포넌트를 조합하여 UI 개발 생산성을 크게 향상시킬 수 있습니다.

## 3. 코드 품질 및 개발 문화

### 3.1. 정적 분석 도구(Linter, Formatter) 설정 강화

- **문제점**: 현재 ESLint와 Prettier가 설정되어 있지만, 규칙이 느슨하거나 팀 전체에 일관되게 적용되지 않을 수 있습니다.
- **개선 제안**:
    1.  **엄격한 규칙 적용**: `eslint-plugin-import-helpers`를 추가하여 import 순서를 강제하고, `eslint-plugin-unused-imports`로 불필요한 import를 자동으로 제거하도록 설정합니다.
    2.  **Husky와 lint-staged 도입**: Git 커밋 전에 자동으로 Linter와 Formatter가 실행되도록 `husky`와 `lint-staged`를 설정하여, 팀원들이 규칙을 잊더라도 코드 스타일이 강제로 일관되게 유지되도록 합니다.
- **기대 효과**:
    - **코드 품질 향상**: 잠재적인 버그를 줄이고 코드 가독성을 높입니다.
    - **리뷰 효율성 증대**: 코드 스타일과 관련된 불필요한 리뷰 코멘트를 줄이고, 비즈니스 로직에 더 집중할 수 있습니다.

### 3.2. 절대 경로(Absolute Path) 설정

- **문제점**: `../../components/Navbar`와 같이 상대 경로를 사용하면, 파일 구조가 깊어질수록 경로가 복잡해지고(일명 "경로 지옥"), 파일 위치 변경 시 유지보수가 어려워집니다.
- **개선 제안**:
    1.  **`tsconfig.json` 설정**: `compilerOptions`에 `baseUrl`과 `paths`를 설정하여 `@/components/*`, `@/lib/*`와 같은 절대 경로를 사용할 수 있도록 합니다.
        ```json
        "baseUrl": ".",
        "paths": {
          "@/*": ["src/*"]
        }
        ```
- **기대 효과**:
    - **가독성 및 유지보수성 향상**: import 구문이 간결해지고, 파일의 위치를 옮기더라도 import 경로를 수정할 필요가 없어집니다.

### 3.3. 상세한 README 및 개발 문서화

- **문제점**: `README.md`에 프로젝트의 상세한 아키텍처, 설정 방법, 주요 기술 결정 사항 등이 충분히 기록되어 있지 않아, 새로운 팀원이 프로젝트 구조를 파악하고 개발에 참여하는 데 시간이 오래 걸립니다.
- **개선 제안**: `README.md` 또는 별도의 `CONTRIBUTING.md` 파일에 프로젝트 구조(디렉토리별 역할), 필요한 환경 변수 설정 방법, 주요 아키텍처 결정 사항(Supabase 선택 이유, 상태 관리 전략 등)을 상세히 문서화합니다.
- **기대 효과**: 새로운 팀원의 온보딩 시간을 단축하고, 프로젝트의 규칙과 구조에 대한 공통된 이해를 바탕으로 협업 효율성을 높입니다.

### 3.4. 테스트 전략 도입

- **문제점**: 자동화된 테스트 코드가 부재하여, 새로운 기능을 추가하거나 기존 코드를 리팩토링할 때 잠재적인 버그를 사전에 발견하기 어렵고, 코드 변경에 대한 안정성을 보장할 수 없습니다.
- **개선 제안**: `Jest`와 `React Testing Library`를 도입하여 점진적으로 테스트를 추가합니다. 1단계로 `lib/utils.ts` 같은 순수 함수나 간단한 UI 컴포넌트에 대한 단위 테스트를 작성하고, 2단계로 회원가입, 투표 생성 등 주요 사용자 플로우에 대한 통합 테스트를 작성합니다.
- **기대 효과**: 코드 변경 시 기존 기능의 동작을 보장하여 안정성을 높이고, 자동화된 테스트를 통해 자신감 있게 배포할 수 있습니다.

### 3.5. 데이터 시딩을 통한 로컬 개발 환경 강화

- **문제점**: 로컬 개발 환경에서 일관된 테스트 데이터를 주입하는 절차가 없어, 개발자마다 각기 다른 데이터로 테스트하게 되어 버그 재현이 어렵고 비효율적인 QA가 진행될 수 있습니다.
- **개선 제안**: 로컬 개발 환경을 위한 데이터 시딩(seeding) 스크립트를 마련합니다. Supabase CLI의 `seed.sql` 기능이나 별도의 TypeScript 스크립트를 `package.json`에 등록하여(`npm run db:seed`), 모든 팀원이 동일한 샘플 데이터 환경에서 개발 및 테스트를 진행할 수 있도록 합니다.
- **기대 효과**: 모든 팀원이 동일한 데이터셋으로 작업하여 버그 재현 및 QA가 용이해지며, 스크립트 실행 한 번으로 테스트 환경을 구축하여 개발 효율성을 높입니다.

### 4.1. 명확한 컴포넌트 구조 확립

- **문제점**: 현재 `components` 디렉터리 내에 `ui` 외에는 별다른 구조적 구분이 없어, 프로젝트가 커질수록 컴포넌트를 찾고 관리하기 어려워집니다.
- **개선 제안**: `components` 디렉터리를 역할에 따라 세분화하여 구조를 명확히 합니다.
    - **`@/components/common`**: 버튼, 인풋, 카드 등 특정 도메인에 종속되지 않고 애플리케이션 전반에서 사용되는 범용 컴포넌트.
    - **`@/components/domain`**: `polls`, `users` 등 특정 도메인과 관련된 비즈니스 로직을 포함하는 컴포넌트 (예: `PollCard`, `UserProfileForm`).
    - **`@/components/layout`**: `Navbar`, `Footer`, `Sidebar` 등 페이지의 전체적인 구조를 잡는 레이아웃 컴포넌트.
- **기대 효과**: 컴포넌트의 역할과 책임이 명확해져 유지보수성이 향상되고, 필요한 컴포넌트를 쉽게 찾을 수 있어 개발 생산성이 높아집니다.

### 4.2. 커스텀 훅(Custom Hooks)을 통한 로직 재사용

- **문제점**: 여러 컴포넌트에서 반복적으로 사용되는 클라이언트 사이드 로직(예: `window.innerWidth`를 추적하여 반응형 UI를 제어하는 로직, `localStorage` 접근 로직)이 각 컴포넌트에 중복 작성될 수 있습니다.
- **개선 제안**: `src/hooks` 디렉터리를 생성하고, 재사용 가능한 로직을 커스텀 훅으로 분리합니다. (예: `useWindowSize`, `useLocalStorage`).
- **기대 효과**: 코드 중복을 제거하고, 복잡한 로직을 캡슐화하여 컴포넌트를 더 간결하고 읽기 쉽게 만듭니다. 테스트 또한 용이해집니다.

### 4.3. 상수(Constants) 중앙 관리

- **문제점**: API 경로, 캐시 키, 특정 숫자(예: 페이지당 아이템 수) 등 애플리케이션 전반에서 사용되는 값들이 코드에 하드코딩되어 있어, 변경이 필요할 때 여러 파일을 수정해야 하고 실수를 유발하기 쉽습니다.
- **개선 제안**: `src/constants` 디렉터리를 만들어 API 엔드포인트, 라우팅 경로, 쿼리 키 등을 상수 파일로 분리하여 중앙에서 관리합니다.
- **기대 효과**: '매직 넘버'나 '매직 스트링'을 제거하여 코드의 가독성과 일관성을 높이고, 변경이 필요할 때 상수 파일만 수정하면 되므로 유지보수성이 크게 향상됩니다.

## 5. 운영 및 모니터링

### 5.1. 프로덕션 에러 모니터링 시스템 도입

- **문제점**: 현재 프로덕션 환경에서 발생하는 클라이언트/서버 에러를 체계적으로 수집하고 분석하는 시스템이 부재하여, 사용자가 겪는 문제를 파악하고 디버깅하기 어렵습니다.
- **개선 제안**: `Sentry`와 같은 외부 에러 모니터링 서비스를 도입하여, Next.js 애플리케이션에서 발생하는 예외를 실시간으로 추적하고 알림을 받도록 설정합니다.
- **기대 효과**: 사용자가 버그를 리포트하기 전에 문제를 선제적으로 파악하고 대응할 수 있으며, 에러 발생 컨텍스트(브라우저, OS, 사용자 행동 등)를 함께 수집하여 디버깅 효율을 높일 수 있습니다.

- **미완성 기능 구체화 (비공개 투표)**
  - **문제**: '비공개 투표' UI는 있지만, 실제 접근 제어 로직(목록 숨김, URL 접근 권한 확인 등)이 구현되지 않았습니다.
  - **해결**: 비공개 투표의 상세 정책을 정의하고 관련 로직을 구현하여 기능을 완성합니다.

---

## 요약 및 권장 로드맵

### 1단계 (즉시 - 완료): P0 치명적 버그 해결 ✅

- ✅ **투표 옵션 선택 상태 공유 문제** - `selectedOptionIds` 패턴으로 해결
- ✅ **만료 시간 null 처리 문제** - `isPollExpired`, `formatExpiryDate` 유틸 함수로 해결

**결과**: 서비스의 핵심 기능이 정상 작동하게 되었습니다.

---

### 2단계 (단기 - 1시간 이내): P1 빠른 승리 전략 ⚡

**즉시 처리 권장 (ROI가 가장 높은 작업들)**:

| 순위 | 이슈 | 작업 시간 | 효과 | 누적 시간 |
|------|------|----------|------|----------|
| 1 | P1-1: Poll 타입 수정 | 5분 | 타입 안전성 | 5분 |
| 2 | P1-2: Next.js Image 마이그레이션 | 5분 | 호환성 보장 | 10분 |
| 3 | P1-3: DB 인덱스 추가 | 5분 | 성능 10~100배 | 15분 |
| 4 | P1-4: 서버 검증 로직 | 30분 | 데이터 무결성 | 45분 |
| 5 | P1-5: Supabase 인스턴스 최적화 | 10분 | 메모리 효율 | 55분 |

**총 소요 시간**: 약 1시간
**예상 효과**: 안정성, 성능, 보안, 호환성 모두 대폭 향상

---

### 3단계 (중기 - 스프린트 계획): P1 장기 과제

- **P1-6: 테스트 코드 도입** (2~7시간, 점진적 도입 가능)
  - Jest + React Testing Library: 유틸 함수, 컴포넌트 테스트
  - Playwright: E2E 핵심 플로우 테스트
  - 회귀 테스트 자동화로 안정성 대폭 향상

---

### 4단계 (중기): P2 UX/UI 개선

- 로딩/에러 상태 피드백 개선
- 타임존 오차 수정
- 디자인 시스템 일관성 확보
- 전역 스타일 정리 및 메타데이터 업데이트
- 구 버전 페이지 정리

---

### 5단계 (장기): P3 코드 품질 개선

- 중복 로직 제거
- 환경 변수 검증
- 폼 관리 개선 (react-hook-form)
- 비공개 투표 기능 완성

---

## 실행 추천 순서

**오늘 당장 (1시간)**:
```bash
# P1-1 ~ P1-5를 순서대로 처리
1. types.ts 수정 (5분)
2. Image 컴포넌트 수정 (5분)
3. DB 인덱스 추가 (5분)
4. create_new_poll 검증 로직 추가 (30분)
5. Supabase 인스턴스 useMemo 적용 (10분)
```

**이번 주 내**:
- P1-6: 테스트 프레임워크 세팅 및 첫 테스트 작성

**다음 스프린트**:
- P2: UX 개선 작업
- P3: 코드 품질 개선

이 로드맵을 따르면 기술 부채를 체계적으로 해소하고 안정적인 서비스를 구축할 수 있습니다.
